const float PI = 3.1415926535897932384626433; // That enough digits?

uniform mat4 shadowMatrix;

float visibility(vec2 diff, sampler2D shadowMap, float mapOffsetY, float bias)
{

    float angle = mod(atan(diff.y, -diff.x) - radians(45.0), 2*PI);
    int quadrant = int(clamp( angle / radians(90.0), 0, 3));
    float shadowMapOffset = quadrant * 0.25;

    vec2 shadowPoint;
    switch(quadrant) // Top, Right, Bottom, Left
    {
        case 0: shadowPoint = diff; break;
        case 1: shadowPoint = vec2(-diff.y, diff.x); break;
        case 2: shadowPoint = -diff; break;
        case 3: shadowPoint = vec2(diff.y, -diff.x); break;
    }

    vec4 s = shadowMatrix * vec4(shadowPoint, 0.0, 1.0);
    s.xyz /= s.w;
    float su = s.x * 0.5 + 0.5;
    float sz = distance(diff, vec2(0));

    float shadowDepth = texture(shadowMap, vec2(su / 4 + shadowMapOffset, mapOffsetY)).r;

    return sz - (shadowDepth + bias);
}

bool doesOcclude(vec2 diff, sampler2D shadowMap, float mapOffsetY, float bias)
{
    return visibility(diff, shadowMap, mapOffsetY, bias) > 0;
}
